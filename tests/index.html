<!doctype html>
<html>
    <head>
        <meta charset="UTF-8" />
		<meta name="HandheldFriendly" content="true" />
		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black" />
		<meta name="apple-mobile-web-app-title" content="VirtualDialScan"/>
		<meta name="viewport" content="initial-scale=1 maximum-scale=1 user-scalable=0 minimal-ui" />
		<link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
		<link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
		<link rel="icon" type="image/png" sizes="192x192"  href="android-icon-192x192.png">
		<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
		<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
		<link rel="manifest" href="manifest.json">
		<meta name="msapplication-TileColor" content="#ffffff">
		<meta name="msapplication-TileImage" content="ms-icon-144x144.png">
		<meta name="theme-color" content="#ffffff">
        <title>VirtualDialScan</title>
        <script src="//cdn.jsdelivr.net/phaser/2.5.0/phaser.min.js"></script>
		
		<style>
			html, body, #game { height: 100%; }
			body{margin: 0; padding: 0;}
		</style>
	
    </head>
    <body style="padding:0px; margin:0px;">
	<div id="vds-add-image-modal-frame" style="display: none; position: fixed; z-index: 1; padding: 0px; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);">
		<div id="vds-add-image-modal-window" style="background: #efefee; bottom: 0; height: 90%;left: 0;margin: auto;position: absolute;top: 0;right: 0;width: 95%;border-radius:15px; border: 2px solid black; padding: 10px;">
			<div style="height: 150px; overflow: auto;">
				<h2 style="margin:0px; padding:0px; font-weight: bold; align: center; text-align: center;">Add image...</h2>
				<ul style="margin:0px; padding:0px; padding-left:10px; margin-left: 15px;">
					<li>Browse: <input type="file" id="fileChooser" onchange="handleFiles(this.files); document.getElementById('vds-add-image-modal-frame').style.display='none';"/></li>
					<!-- <li>(Optional) Description: <input type="text" style="width:100px;" id="image_caption"></input>&nbsp;<input type="button" onclick="document.getElementById('image_caption').value = '';" value="Clear Description"></button></li>-->
					<li>Search Online:
						<ul>
							<li>Type:
								<select id="search_type_pixabay" name="search_type_pixabay" style="width:100px">
									<option value="">All</option>  
									<option value="photo">Photo</option>
									<option value="illustration">Illustration</option>
									<option value="vector">Vector Graphics</option>
								</select>
							</li>
							<li>Text: &nbsp;<input style="width:100px" type="text" id="search_str_pixabay"></input>&nbsp;<input type="button" onclick="getResults();" value="Search"></button></li>
						</ul>
					</li>
				</ul>
			</div>

			<div id="results" style="border-radius:10px; position: absolute; top: 150px; bottom: 50px; left:15px; right:15px; overflow: auto; border: 1px solid black;"></div>
			<div style="position:absolute; bottom:1px; right: 15px; left:15px; height: 45px;padding: 0px;">
				<div style="text-align:left; width:48%; height: 45px; position: absolute; left:0px;vertical-align: middle;">
					<a href="https://pixabay.com"><img src="pixabay.png" width=60/></a>
				</div>
				<div style="text-align:right; width:48%; height: 45px; position: absolute; right:0px; vertical-align: middle;">
					<input type="button" onclick="document.getElementById('vds-add-image-modal-frame').style.display='none';" value="Cancel">
				</div>
			</div>

		</div>
	</div>
<!-- 	<input type="file" id="fileChooser" onchange="handleFiles(this.files)" style="display:none" /> -->
    <script type="text/javascript">

	function selectImageForSpot(strUrl)
	{
		try {
			game.cache.removeImage(positionToPlaceImage+'image');
		} catch(e) {};
		
		this.game.load.image(positionToPlaceImage+'image', strUrl);
		this.game.load.onLoadComplete.addOnce(function() { 
			onLoaded(); 
		})

		this.game.load.crossOrigin = 'anonymous';
		this.game.load.start();
	}

	function onLoaded()
	{
		if(positionToPlaceImage == "TL") {
			buttonTopL.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonTopL, finalImageWidth);
		} else if(positionToPlaceImage == "TM") {
			buttonTopM.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonTopM, finalImageWidth);
		} else if(positionToPlaceImage == "TR") {
			buttonTopR.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonTopR, finalImageWidth);
		} else if(positionToPlaceImage == "ML") {
			buttonMiddleL.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonMiddleL, finalImageWidth);
		} else if(positionToPlaceImage == "MR") {
			buttonMiddleR.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonMiddleR, finalImageWidth);
		} else if(positionToPlaceImage == "BL") {
			buttonBottomL.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonBottomL, finalImageWidth);
		} else if(positionToPlaceImage == "BM") {
			buttonBottomM.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonBottomM, finalImageWidth);
		} else if(positionToPlaceImage == "BR") {
			buttonBottomR.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonBottomR, finalImageWidth);						
		}
		
		document.getElementById("vds-add-image-modal-frame").style.display="none";
	}
	
	function reqListener () {
		var searchResults = JSON.parse(this.responseText);
		if(searchResults.hits.length > 0)
		{
			var divResults = document.getElementById("results");
			divResults.innerHTML = "";
			for(var i = 0; (i < searchResults.hits.length && i < 50); i++)
			{
				divResults.innerHTML += "<a href='#' onclick='selectImageForSpot(\""+searchResults.hits[i].webformatURL+"\");'><img src='" + searchResults.hits[i].previewURL + "' width=25%/></a>";
			}
		}
	}
	
	function getResults()
	{
		//https://pixabay.com/api/?key=3976912-9d9940a8368ab5e4c9ece4806&q=yellow+flowers&image_type=photo
		//type: vector, photo, illustration
		var strQuery = document.getElementById("search_str_pixabay").value;
		var strType = document.getElementById("search_type_pixabay").value;
		var strUrl = "https://pixabay.com/api/?key=3976912-9d9940a8368ab5e4c9ece4806&q="+strQuery+"&image_type="+strType;
		
		var oReq = new XMLHttpRequest();
		oReq.addEventListener("load", reqListener);
		oReq.open("GET", strUrl);
		oReq.send();
	}
	
	//Phaser Game Variable
	var game;
	
	//////// Sizes / Widths / Heights
	var toolbarSz = 100; //window.innerWidth*.15;
	var gameWidth = window.innerWidth-1-toolbarSz;
	var gameHeight = window.innerHeight-1;
	var padd = 20; //*gameWidth/1087;
	var finalImageWidth = Math.min(gameWidth/3, gameHeight/3) - padd*2;
	
	//////// Arrow variables:
	//Arrow sprite
	var arrowSprite;
	//Arrow movement (yes/no)
	var move = true;
	//Arrow speed
	var speed = 1;
	
	//////// Selectable areas variables:
	//Buttons for the selectable areas
	var buttonTopL, buttonTopM, buttonTopR, buttonMiddleL, buttonMiddleR, buttonBottomL, buttonBottomM, buttonBottomR;
	//Rectangles for the selectable areas
	var rectangleTL, rectangleTM, rectangleTR, rectangleML, rectangleMR, rectangleBL, rectangleBM, rectangleBR;
	//Hover Sprites for the selectable areas
	var spriteTL, spriteTM, spriteTR, spriteML, spriteMR, spriteBL, spriteBM, spriteBR;
	//Color to hover the selectable areas with
	var tintColor = 'rgba(255,255,255, 0.3)';

	//Sprite groups (help us define the Z-order of elements grouped in these)
	var backgrndGrp
	var toolbarGrp;
	var topGrp;
	var buttonGrp;
	var topMostGrp;
	
	////////// Toolbar Variables:
	//Toolbar Rectangle + Toolbar Sprite
	var toolbar;
	var spriteToolbar;
	//Toolbar buttons
	var buttonNextLevel, buttonPreviousLevel, buttonChangeColorSchema;
	//Text containing current level
	var textLevel;
	//Toolbar background color
	var toolbarColor = '#eeeeee';
	
	////////// Other Variables:
	//Color Scheme
	var currentSchema = 0;
	//Position where the Image will be placed (used by the FileAPI handler)
	var positionToPlaceImage = "";
	//Control variable to know if a button on the toolbar has been pressed
	var toolbarButtonClicked = 0;
	//Handle to the Get (URL) Parameters and change default values (even load images?)
	
	//FullScreen mode is on?
	var fullScreen = 0;
	var fullScreenBtn;
	var fullScreenBtnX;
	var fullScreenBtnY;
	
	function LoadDataFromString(str_data_to_load)
	{
		var splitstring = str_data_to_load.split('|');
		if(splitstring.length != 11)
		{
			alert("An error occurred while trying to load Saved Data for VirtualDialScan [Error: invalid number of parameters]");
		}
		else
		{
			var savedName = splitstring[0];
			var savedDate = splitstring[1];
			var savedSpeed = splitstring[2];
			var saveTL = splitstring[3];
			var saveTM = splitstring[4];
			var saveTR = splitstring[5];
			var saveML = splitstring[6];
			var saveMR = splitstring[7];
			var saveBL = splitstring[8];
			var saveBM = splitstring[9];
			var saveBR = splitstring[10];
			
			//alert("Was able to load the saved data name '"+savedName+"' from '"+new Date(savedDate)+"'!");
			//now replace the data onto the images and the speed
			this.speed = savedSpeed;
			var level = (speed < 5) ? speed : speed/5 + 4;
			this.textLevel.setText( "Level "+level);
			
			if(saveTL != 'none')
			{
				this.positionToPlaceImage = "TL";

				if(saveTL.startsWith("http://") || saveTL.startsWith("https://"))
				{
					//URL for image
					selectImageForSpot(saveTL);
				}
				else
				{
					//base64 content
					placeB64ImageOnPosition(saveTL);
				}
			}
			if(saveTM != 'none')
			{
				this.positionToPlaceImage = "TM";

				if(saveTM.startsWith("http://") || saveTM.startsWith("https://"))
				{
					//URL for image
					selectImageForSpot(saveTM);
				}
				else
				{
					//base64 content
					placeB64ImageOnPosition(saveTM);
				}
			}
			if(saveTR != 'none')
			{
				this.positionToPlaceImage = "TR";

				if(saveTR.startsWith("http://") || saveTR.startsWith("https://"))
				{
					//URL for image
					selectImageForSpot(saveTR);
				}
				else
				{
					//base64 content
					placeB64ImageOnPosition(saveTR);
				}
			}
			if(saveML != 'none')
			{
				this.positionToPlaceImage = "ML";

				if(saveML.startsWith("http://") || saveML.startsWith("https://"))
				{
					//URL for image
					selectImageForSpot(saveML);
				}
				else
				{
					//base64 content
					placeB64ImageOnPosition(saveML);
				}
			}
			if(saveMR != 'none')
			{
				this.positionToPlaceImage = "MR";

				if(saveMR.startsWith("http://") || saveMR.startsWith("https://"))
				{
					//URL for image
					selectImageForSpot(saveMR);
				}
				else
				{
					//base64 content
					placeB64ImageOnPosition(saveMR);
				}
			}
			if(saveBL != 'none')
			{
				this.positionToPlaceImage = "BL";

				if(saveBL.startsWith("http://") || saveBL.startsWith("https://"))
				{
					//URL for image
					selectImageForSpot(saveBL);
				}
				else
				{
					//base64 content
					placeB64ImageOnPosition(saveBL);
				}
			}
			if(saveBM != 'none')
			{
				this.positionToPlaceImage = "BM";

				if(saveBM.startsWith("http://") || saveBM.startsWith("https://"))
				{
					//URL for image
					selectImageForSpot(saveBM);
				}
				else
				{
					//base64 content
					placeB64ImageOnPosition(saveBM);
				}
			}
			if(saveBR != 'none')
			{
				this.positionToPlaceImage = "BR";

				if(saveBR.startsWith("http://") || saveBR.startsWith("https://"))
				{
					//URL for image
					selectImageForSpot(saveBR);
				}
				else
				{
					//base64 content
					placeB64ImageOnPosition(saveBR);
				}
			}
		}
	}
	
	function getJsonFromUrl()
	{
		var query = location.search.substr(1);
		var result = {};
		query.split("&").forEach(function(part) {
			var item = part.split("=");
			result[item[0]] = decodeURIComponent(item[1]);
		});
		
		return result;
	}
	
	function placeB64ImageOnPosition(src)
	{
		var data = new Image();
		data.src = src;
		try {
			game.cache.removeImage(positionToPlaceImage+'image');
		} catch(e) {};
		
		var newImage = game.cache.addImage(positionToPlaceImage+'image', src, data);
		
		if(positionToPlaceImage == "TL") {
			buttonTopL.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonTopL, finalImageWidth);
		} else if(positionToPlaceImage == "TM") {
			buttonTopM.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonTopM, finalImageWidth);
		} else if(positionToPlaceImage == "TR") {
			buttonTopR.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonTopR, finalImageWidth);
		} else if(positionToPlaceImage == "ML") {
			buttonMiddleL.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonMiddleL, finalImageWidth);
		} else if(positionToPlaceImage == "MR") {
			buttonMiddleR.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonMiddleR, finalImageWidth);
		} else if(positionToPlaceImage == "BL") {
			buttonBottomL.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonBottomL, finalImageWidth);
		} else if(positionToPlaceImage == "BM") {
			buttonBottomM.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonBottomM, finalImageWidth);
		} else if(positionToPlaceImage == "BR") {
			buttonBottomR.loadTexture(positionToPlaceImage+'image', 0);
			ResizeButton(buttonBottomR, finalImageWidth);						
		}
	}
	
	function handleFiles(files)
	{
		// Loop through the FileList and render image files as thumbnails.
		for (var i = 0, f; f = files[i]; i++) {
			selectedImageName = f.name;
			
			var reader = new FileReader();

			// Closure to capture the file information.
			reader.onload = (function(theFile) 
			{
				return function(e) 
				{
					dataURI = e.target.result;

					placeB64ImageOnPosition(dataURI);
				};
			})(f);

			// Read in the image file as a data URL.
			reader.readAsDataURL(f);
		}
	}
	
	function preload() {
	
		//game.load.script('filter', 'js/filters/ColorMatrixFilter.js');
		game.load.image('arrowW', 'set1/arrowW.png');
		game.load.image('arrowB', 'set1/arrowB.png');

		game.load.image('buttonPlus','set1/plus.png');
		game.load.image('buttonMinus','set1/minus.png');

		game.load.image('buttonSearch','set1/file_search.png');

		game.load.image('buttonColor', 'set1/color.png');
		game.load.image('buttonSave', 'set1/save.png');
		
		game.load.spritesheet('buttonNoPicW', 'set1/nopicW.png', 615, 615);
		game.load.spritesheet('buttonNoPicB', 'set1/nopicB.png', 614, 614);
	}
	
	function applySchema(schemaID)
	{
		switch(schemaID)
		{
			case 0:
				game.stage.backgroundColor = '#222222';
				tintColor = 'rgba(255,255,255, 0.3)';
				toolbarColor = '#ffffff'
		
				textLevel.style.fill = '#444444';
				//change buttons
				arrowSprite.loadTexture('arrowW');
				
				if(buttonTopL.key == "buttonNoPicB")
					buttonTopL.loadTexture("buttonNoPicW", 0, false);
				if(buttonTopM.key == "buttonNoPicB")
					buttonTopM.loadTexture("buttonNoPicW", 0, false);
				if(buttonTopR.key == "buttonNoPicB")
					buttonTopR.loadTexture("buttonNoPicW", 0, false);
				if(buttonMiddleL.key == "buttonNoPicB")
					buttonMiddleL.loadTexture("buttonNoPicW", 0, false);
				if(buttonMiddleR.key == "buttonNoPicB")
					buttonMiddleR.loadTexture("buttonNoPicW", 0, false);
				if(buttonBottomL.key == "buttonNoPicB")
					buttonBottomL.loadTexture("buttonNoPicW", 0, false);
				if(buttonBottomM.key == "buttonNoPicB")
					buttonBottomM.loadTexture("buttonNoPicW", 0, false);
				if(buttonBottomR.key == "buttonNoPicB")
					buttonBottomR.loadTexture("buttonNoPicW", 0, false);
				

				break;
			case 1:
				game.stage.backgroundColor = '#eeeeee';
				tintColor = 'rgba(122,123,122, 0.3)';
				toolbarColor = '#333333'
				
				textLevel.style.fill = '#eeeeee';

				//change buttons
				arrowSprite.loadTexture('arrowB');

				if(buttonTopL.key == "buttonNoPicW")
					buttonTopL.loadTexture("buttonNoPicB", 0, false);
				if(buttonTopM.key == "buttonNoPicW")
					buttonTopM.loadTexture("buttonNoPicB", 0, false);
				if(buttonTopR.key == "buttonNoPicW")
					buttonTopR.loadTexture("buttonNoPicB", 0, false);
				if(buttonMiddleL.key == "buttonNoPicW")
					buttonMiddleL.loadTexture("buttonNoPicB", 0, false);
				if(buttonMiddleR.key == "buttonNoPicW")
					buttonMiddleR.loadTexture("buttonNoPicB", 0, false);
				if(buttonBottomL.key == "buttonNoPicW")
					buttonBottomL.loadTexture("buttonNoPicB", 0, false);
				if(buttonBottomM.key == "buttonNoPicW")
					buttonBottomM.loadTexture("buttonNoPicB", 0, false);
				if(buttonBottomR.key == "buttonNoPicW")
					buttonBottomR.loadTexture("buttonNoPicB", 0, false);
				
				break;
			/*case 2:
				game.stage.backgroundColor = '#E6E6FA';
				tintColor = 'rgba(0,255,255, 0.3)';
				toolbarColor = '#66eeff'
				break;*/
			default:
				game.stage.backgroundColor = '#000000';
				tintColor = 'rgba(255,255,255, 0.3)';
				toolbarColor = '#ffffff'
				arrowSprite.loadTexture('arrowW');
				break;
		}

		var bmd = spriteToolbar.key;
		paintBMDRect(bmd, toolbar.width, toolbar.height, toolbarColor);
	}
	
	function changeSchema()
	{
		currentSchema+=1;
		if(currentSchema == 2)
		{
			currentSchema = 0; //only 2 schemas available at the moment...
		}
		
		applySchema(currentSchema);
		
		toolbarButtonClicked = 1;
		move = 1;
	}
	
	function clearBMDRect(bmd)
	{
		bmd.clear();
	}
	
	function paintBMDRect(bmd, width, height, color)
	{
		bmd.clear();
		bmd.ctx.beginPath();
		bmd.ctx.rect(0, 0, width, height);
		bmd.ctx.fillStyle = color;
		bmd.ctx.fill();
	}
	
	function drawRECT(rect, color, group)
	{
		var drawObj;
		var width = rect.width;
		var height = rect.height;
		var bmd = game.add.bitmapData(width, height);
		paintBMDRect(bmd, width, height, color);
		
		drawObj = game.add.sprite(rect.x, rect.y, bmd);
		drawObj.anchor.setTo(0.0, 0.0);

		group.add(drawObj);
		
		return drawObj;
	}

/*	function handleIncorrect(){
     	if(!game.device.desktop){
     		document.getElementById("turn").style.display="block";
     	}
	}
	
	function handleCorrect(){
		if(!game.device.desktop){
			document.getElementById("turn").style.display="none";
		}
	}
*/
	function resize() {
		
		this.game.scale.refresh();

		//re-calculate the position of elements:
		//toolbarSz = window.innerWidth*.15;

		game.scale.setGameSize(window.innerWidth, window.innerHeight);

		gameWidth = window.innerWidth-1-toolbarSz;
		gameHeight = window.innerHeight-1;
		//padd = 20*gameWidth/1087;
		finalImageWidth = Math.min(gameWidth/3, gameHeight/3) - padd*2;

		buttonTopL.x = padd;
		buttonTopL.y = padd;
		ResizeButton(buttonTopL, finalImageWidth);
		spriteTL.x = buttonTopL.x;
		spriteTL.y = buttonTopL.y;
		spriteTL.width = finalImageWidth;
		spriteTL.height = finalImageWidth;

		buttonTopM.x = gameWidth/2 - finalImageWidth/2;
		buttonTopM.y = padd;
		ResizeButton(buttonTopM, finalImageWidth);
		spriteTM.x = buttonTopM.x;
		spriteTM.y = buttonTopM.y;
		spriteTM.width = finalImageWidth;
		spriteTM.height = finalImageWidth;

		buttonTopR.x = gameWidth - finalImageWidth - padd;
		buttonTopR.y = padd;
		ResizeButton(buttonTopR, finalImageWidth);
		spriteTR.x = buttonTopR.x;
		spriteTR.y = buttonTopR.y;
		spriteTR.width = finalImageWidth;
		spriteTR.height = finalImageWidth;

		buttonMiddleL.x = padd;
		buttonMiddleL.y = gameHeight/2 - finalImageWidth/2;
		ResizeButton(buttonMiddleL, finalImageWidth);
		spriteML.x = buttonMiddleL.x;
		spriteML.y = buttonMiddleL.y;
		spriteML.width = finalImageWidth;
		spriteML.height = finalImageWidth;

		buttonMiddleR.x = gameWidth - finalImageWidth - padd;
		buttonMiddleR.y = gameHeight/2 - finalImageWidth/2;
		ResizeButton(buttonMiddleR, finalImageWidth);
		spriteMR.x = buttonMiddleR.x;
		spriteMR.y = buttonMiddleR.y;
		spriteMR.width = finalImageWidth;
		spriteMR.height = finalImageWidth;

		buttonBottomL.x = padd;
		buttonBottomL.y = gameHeight - finalImageWidth - padd;
		ResizeButton(buttonBottomL, finalImageWidth);
		spriteBL.x = buttonBottomL.x;
		spriteBL.y = buttonBottomL.y;
		spriteBL.width = finalImageWidth;
		spriteBL.height = finalImageWidth;

		buttonBottomM.x = gameWidth/2 - finalImageWidth/2;
		buttonBottomM.y = gameHeight - finalImageWidth - padd;
		ResizeButton(buttonBottomM, finalImageWidth);
		spriteBM.x = buttonBottomM.x;
		spriteBM.y = buttonBottomM.y;
		spriteBM.width = finalImageWidth;
		spriteBM.height = finalImageWidth;

		buttonBottomR.x = gameWidth - finalImageWidth - padd;
		buttonBottomR.y = gameHeight - finalImageWidth - padd;
		ResizeButton(buttonBottomR, finalImageWidth);
		spriteBR.x = buttonBottomR.x;
		spriteBR.y = buttonBottomR.y;
		spriteBR.width = finalImageWidth;
		spriteBR.height = finalImageWidth;

		arrowSprite.body.x = gameWidth/2;
		arrowSprite.x = gameWidth/2;
		arrowSprite.body.y = gameHeight/2;
		arrowSprite.y = gameHeight/2;
		var minProportion = Math.min(gameWidth, gameHeight);
		var arrowProportion = minProportion / 2300;
		arrowSprite.scale.setTo(arrowProportion, arrowProportion);
		

		spriteToolbar.x = gameWidth;
		spriteToolbar.height = gameHeight;
		spriteToolbar.y = 0;

		buttonPreviousLevel.x = gameWidth + padd;
		buttonNextLevel.x = gameWidth + toolbarSz - padd - toolbarSz/4;

		textLevel.x = gameWidth + padd/2;
		textLevel.y = padd;
		
		buttonChangeColorSchema.x = gameWidth + padd;
		buttonChangeColorSchema.y = gameHeight - padd*2 - buttonNextLevel.height - 200;

		buttonSave.x = gameWidth + toolbarSz - padd - toolbarSz/4;
		buttonSave.y = gameHeight - padd*2 - buttonNextLevel.height - 200;
	}

	function saveData() {

		var savename = window.prompt("Name of Saved Data", "name");
		//Get data to save:
		//Speed
		//b64 img of each spot (TL, TM, TR, ML, MR, BL, BM, BR)

		var TLsrc = "none";
		var TMsrc = "none";
		var TRsrc = "none";
		var MLsrc = "none";
		var MRsrc = "none";
		var BLsrc = "none";
		var BMsrc = "none";
		var BRsrc = "none";

		if((buttonTopL.key != "buttonNoPicW") && (buttonTopL.key != "buttonNoPicB"))
		{
			TLsrc = game.cache.getImage('TLimage').src
		}

		if((buttonTopM.key != "buttonNoPicW") && (buttonTopM.key != "buttonNoPicB"))
		{
			TMsrc = game.cache.getImage('TMimage').src
		}

		if((buttonTopR.key != "buttonNoPicW") && (buttonTopR.key != "buttonNoPicB"))
		{
			TRsrc = game.cache.getImage('TRimage').src
		}

		if((buttonMiddleL.key != "buttonNoPicW") && (buttonMiddleL.key != "buttonNoPicB"))
		{
			MLsrc = game.cache.getImage('MLimage').src
		}

		if((buttonMiddleR.key != "buttonNoPicW") && (buttonMiddleR.key != "buttonNoPicB"))
		{
			MRsrc = game.cache.getImage('MRimage').src
		}

		if((buttonBottomL.key != "buttonNoPicW") && (buttonBottomL.key != "buttonNoPicB"))
		{
			BLsrc = game.cache.getImage('BLimage').src
		}

		if((buttonBottomM.key != "buttonNoPicW") && (buttonBottomM.key != "buttonNoPicB"))
		{
			BMsrc = game.cache.getImage('BMimage').src
		}

		if((buttonBottomR.key != "buttonNoPicW") && (buttonBottomR.key != "buttonNoPicB"))
		{
			BRsrc = game.cache.getImage('BRimage').src
		}

		//now build the final string to save:
		var saveStr = savename + "|" + new Date().getTime() + "|" + speed + "|" + TLsrc + "|" + TMsrc + "|" + TRsrc + "|" + MLsrc + "|" + MRsrc + "|" + BLsrc + "|" + BMsrc + "|" + BRsrc;

		
		//Create new GIST with Data:
		/*
			User-Agent: VirtualDialScan
			Content-Type: application/json

			URL: https://api.github.com/gists

			{
			  "description": "the description for this gist",
			  "public": true,
			  "files": {
				"file1.txt": {
				  "content": "String file contents"
				}
			  }
			}
		*/

		var xmlhttp = new XMLHttpRequest();
		var url = "https://api.github.com/gists";
		xmlhttp.open("POST", url, true);
		xmlhttp.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
		//Send the proper header information along with the request
		xmlhttp.onreadystatechange = function() {//Call a function when the state changes.

			if(xmlhttp.readyState == 4 && xmlhttp.status == 201) {
				var object = JSON.parse(xmlhttp.responseText);
				alert("Configuration successfully saved! You can now access this configuration using this URL: " + window.location.protocol + "//" + window.location.host + window.location.pathname + "?saveddata="+object.id);
				window.location = window.location.protocol + "//" + window.location.host + window.location.pathname + "?saveddata="+object.id;
			}
		}

		xmlhttp.send(JSON.stringify({
			  description: "VirtualDialScan-Config-savename-" + new Date().getTime(),
			  public: true,
			  files: { "savefile.txt": { content: saveStr } }
			}));

	}

	function create() {
	
		game.scale.scaleMode = Phaser.ScaleManager.USER_SCALE;
		window.addEventListener('resize', resize);
		this.game.scale.refresh();
		
		//	Enable p2 physics
		game.physics.startSystem(Phaser.Physics.P2JS);
		
		key1 = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
		key1.onDown.add(onClick, this);
		
		key2 = game.input.keyboard.addKey(Phaser.Keyboard.ENTER);
		key2.onDown.add(onClick, this);

		var key3 = game.input.keyboard.addKey(Phaser.Keyboard.PLUS);
		key3.onDown.add(nextLevel, this);

		var key32 = game.input.keyboard.addKey(Phaser.Keyboard.J);
		key32.onDown.add(nextLevel, this);
		
		var key4 = game.input.keyboard.addKey(Phaser.Keyboard.MINUS);
		key4.onDown.add(previousLevel, this);

		var key42 = game.input.keyboard.addKey(Phaser.Keyboard.K);
		key42.onDown.add(previousLevel, this);

		game.input.onTap.add(onClick, this);
		game.input.priorityID = 1;
		toolbar = new Phaser.Rectangle(gameWidth, 0, toolbarSz, gameHeight);
		
		backgrndGrp = game.add.group();
		toolbarGrp = game.add.group();
		buttonGrp = game.add.group();
		topGrp = game.add.group();
		topMostGrp = game.add.group();
		
		spriteToolbar = drawRECT(toolbar, toolbarColor, toolbarGrp);
		
		buttonPreviousLevel = game.add.button(gameWidth + padd, toolbar.y + padd + 50, 'buttonMinus', previousLevel, this, 1, 0, 0);
		buttonPreviousLevel.scale.setTo(toolbarSz/4/buttonPreviousLevel.width, toolbarSz/4/buttonPreviousLevel.width);
		
		buttonNextLevel = game.add.button(gameWidth + toolbarSz - padd - toolbarSz/4, toolbar.y + padd + 50, 'buttonPlus', nextLevel, this, 1, 0, 0);
		buttonNextLevel.scale.setTo(toolbarSz/4/buttonNextLevel.width, toolbarSz/4/buttonNextLevel.width);
		
		buttonChangeColorSchema = game.add.button(gameWidth + padd, gameHeight - padd*2 - buttonNextLevel.height - 200, 'buttonColor', changeSchema, this, 1, 0, 0);
		buttonChangeColorSchema.scale.setTo(toolbarSz/4/buttonChangeColorSchema.width, toolbarSz/4/buttonChangeColorSchema.width);

		buttonSave = game.add.button(gameWidth + toolbarSz - padd - toolbarSz/4,  gameHeight - padd*2 - buttonNextLevel.height - 200, 'buttonSave', saveData, this, 1, 0, 0);
		buttonSave.scale.setTo(toolbarSz/4/buttonSave.width, toolbarSz/4/buttonSave.width);
		
		toolbarGrp.add(buttonNextLevel);
		toolbarGrp.add(buttonPreviousLevel);
		toolbarGrp.add(buttonChangeColorSchema);
		toolbarGrp.add(buttonSave);

		
		
		buttonTopL = game.add.button(padd, padd, 'buttonNoPicW', browseForImage, this, 1, 0, 0);
		buttonTopL.name = "TL";
		rectangleTL = new Phaser.Rectangle(padd, padd, finalImageWidth, finalImageWidth);
		spriteTL = drawRECT(rectangleTL, tintColor, topGrp);

		buttonTopM = game.add.button(gameWidth/2 - finalImageWidth/2, padd, 'buttonNoPicW', browseForImage, this, 1, 0, 0);
		buttonTopM.name = "TM";
		rectangleTM = new Phaser.Rectangle(gameWidth/2 - finalImageWidth/2, padd, finalImageWidth, finalImageWidth);
		spriteTM = drawRECT(rectangleTM, tintColor, topGrp);
		
		buttonTopR = game.add.button(gameWidth - finalImageWidth - padd, padd, 	'buttonNoPicW', browseForImage, this, 1, 0, 0);
		buttonTopR.name = "TR";
		rectangleTR = new Phaser.Rectangle(gameWidth - finalImageWidth - padd, padd, finalImageWidth, finalImageWidth);
		spriteTR = drawRECT(rectangleTR, tintColor, topGrp);
		
		buttonMiddleL = game.add.button(padd, gameHeight/2 - finalImageWidth/2, 'buttonNoPicW', browseForImage, this, 1, 0, 0);
		buttonMiddleL.name = "ML";
		rectangleML = new Phaser.Rectangle(padd, gameHeight/2 - finalImageWidth/2, finalImageWidth, finalImageWidth);
		spriteML = drawRECT(rectangleML, tintColor, topGrp);
		
		buttonMiddleR = game.add.button(gameWidth - finalImageWidth - padd, gameHeight/2 - finalImageWidth/2, 'buttonNoPicW', browseForImage, this, 1, 0, 0);
		buttonMiddleR.name = "MR";
		rectangleMR = new Phaser.Rectangle(gameWidth - finalImageWidth - padd, gameHeight/2 - finalImageWidth/2, finalImageWidth, finalImageWidth);
		spriteMR = drawRECT(rectangleMR, tintColor, topGrp);
		
		buttonBottomL = game.add.button(padd, gameHeight - finalImageWidth - padd, 'buttonNoPicW', browseForImage, this, 1, 0, 0);
		buttonBottomL.name = "BL";
		rectangleBL= new Phaser.Rectangle(padd, gameHeight - finalImageWidth - padd, finalImageWidth, finalImageWidth);
		spriteBL = drawRECT(rectangleBL, tintColor, topGrp);
		
		buttonBottomM = game.add.button(gameWidth/2 - finalImageWidth/2, gameHeight - finalImageWidth - padd, 'buttonNoPicW', browseForImage, this, 1, 0, 0);
		buttonBottomM.name = "BM";
		rectangleBM= new Phaser.Rectangle(gameWidth/2 - finalImageWidth/2, gameHeight - finalImageWidth - padd, finalImageWidth, finalImageWidth);
		spriteBM = drawRECT(rectangleBM, tintColor, topGrp);
		
		buttonBottomR = game.add.button(gameWidth - finalImageWidth - padd, gameHeight - finalImageWidth - padd, 'buttonNoPicW', browseForImage, this, 1, 0, 0);
		buttonBottomR.name = "BR";
		rectangleBR= new Phaser.Rectangle(gameWidth - finalImageWidth - padd, gameHeight - finalImageWidth - padd, finalImageWidth, finalImageWidth);
		spriteBR = drawRECT(rectangleBR, tintColor, topGrp);
		
		buttonGrp.add(buttonTopL);
		buttonGrp.add(buttonTopM);
		buttonGrp.add(buttonTopR);
		buttonGrp.add(buttonMiddleL);
		buttonGrp.add(buttonMiddleR);
		buttonGrp.add(buttonBottomL);
		buttonGrp.add(buttonBottomM);
		buttonGrp.add(buttonBottomR);
				
		ResizeButton(buttonTopL, finalImageWidth);
		ResizeButton(buttonTopM, finalImageWidth);
		ResizeButton(buttonTopR, finalImageWidth);
		
		ResizeButton(buttonMiddleL, finalImageWidth);
		ResizeButton(buttonMiddleR, finalImageWidth);
		
		ResizeButton(buttonBottomR, finalImageWidth);
		ResizeButton(buttonBottomM, finalImageWidth);
		ResizeButton(buttonBottomL, finalImageWidth);
		
		arrowSprite = game.add.sprite(gameWidth/2,gameHeight/2, 'arrowW');
		topGrp.add(arrowSprite);
		
		//Enable the physics body on this sprite and turn off the visual debugger
		game.physics.p2.enable(arrowSprite, true);
					
		//100% W is 1152px
		var minProportion = Math.min(gameWidth, gameHeight);
		var arrowProportion = minProportion / 2300;
		
		//	Clear the shapes and load the 'arrow' polygon from the physicsData JSON file in the cache
		arrowSprite.body.clearShapes();
		arrowSprite.scale.setTo(arrowProportion, arrowProportion);
		
		//Level text
		var level = (speed < 5) ? speed : speed/5 + 4;
		
		var textL = "Level " + level;
		var style = { font: "Arial", fontSize: 60*toolbarSz/288, fill: "#333333", align: "center" }; //BP: TODO: Add text color to the theme!
		textLevel = game.add.text(toolbar.x + padd/2, toolbar.y + padd, textL, style);
		toolbarGrp.add(textLevel);
		//applySchema(currentSchema);
		
		var urlData = getJsonFromUrl();
		if(urlData["saveddata"] != undefined)
		{
			//1st get the data from Gists:
			//https://api.github.com/gists/[ID] e.g.: https://api.github.com/gists/791c8a1ed5b6244501f05c9a2b11de73
			var xmlhttp2 = new XMLHttpRequest();
			var url = "https://api.github.com/gists/" + urlData["saveddata"];
			xmlhttp2.open("GET", url, true);
			xmlhttp2.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
			//Send the proper header information along with the request
			xmlhttp2.onreadystatechange = function() {//Call a function when the state changes.

				if(xmlhttp2.readyState == 4 && xmlhttp2.status == 200) 
				{
					var object = JSON.parse(xmlhttp2.responseText);
					//alert(object.files['savefile.txt'].raw_url);
					
					//now get the file in the RAW_URL
					//2nd get the raw_url of the file and download it locally (it is a string)
					if(object.files['savefile.txt'].truncated == false)
					{
						LoadDataFromString(object.files['savefile.txt'].content);
					}
					else
					{
						var xmlhttp3 = new XMLHttpRequest();
						var url = object.files['savefile.txt'].raw_url;
						xmlhttp3.open("GET", url, true);
						xmlhttp3.setRequestHeader("Content-Type", "application/json;charset=UTF-8");
						//Send the proper header information along with the request
						xmlhttp3.onreadystatechange = function() {//Call a function when the state changes.
						
							if(xmlhttp3.readyState == 4 && xmlhttp3.status == 200) {
								//alert('got the rawFile!!!');
								LoadDataFromString(loadedString);
							}
							else if(xmlhttp3.readyState == 4 && xmlhttp3.status != 200) {
								alert("Error! An error ocurred while trying to get the saved VirtualDialScan configuration. Error code:" + xmlhttp3.status);
							}
						}
						
						xmlhttp3.send();
					}
				}
				else if(xmlhttp2.readyState == 4 && xmlhttp2.status == 404) {
					alert("Error! Saved VirtualDialScan configuration not found or was deleted :(");
				}
				else if(xmlhttp2.readyState == 4 && xmlhttp2.status != 200) {
					alert("Error! An error ocurred while trying to get the saved VirtualDialScan configuration. Error code:" + xmlhttp2.status);
				}
			}

			xmlhttp2.send();
		}
		else
		{
			if(urlData["speed"] != undefined)
			{
				speed = urlData["speed"];
			}
		}
	}

	function nextLevel()
	{
		if(speed < 5)
		{
			speed+=1;
		}
		else
		{
			speed+=5;
		}
		
		//Update Level text
		var level = (speed < 5) ? speed : speed/5 + 4;
		textLevel.setText( "Level "+level);

		toolbarButtonClicked = 1;
		move = 1;
	}
	
	function previousLevel()
	{
		if(speed > 1)
		{
			if(speed <= 5)
			{
				speed-=1;
			}
			else
			{
				speed -= 5;
			}
		}
		
		//Update Level text
		var level = (speed < 5) ? speed : speed/5 + 4;
		textLevel.setText( "Level "+level);
		toolbarButtonClicked = 1;
		move = 1;
	}

	function ResizeButton(button, width)
	{
		button.scale.setTo(1.0, 1.0);
		//100% of images should be finalImageWidth
		//calculate maximum image (width or height)
		var maxImg = Math.max(button.width, button.height);
		var proportion = width/maxImg;
		
		button.scale.setTo(proportion, proportion);
	}

	function browseForImage(button, pointer) 
	{
		console.log('you clicked', button.name);
		positionToPlaceImage = button.name;
		//document.getElementById("fileChooser").click();
		document.getElementById("vds-add-image-modal-frame").style.display="block";
		
		// this is how you load an image dinamically and change the sprite
		//this.game.load.image('profilepic','http://www.w3school.com.cn/i/ct_html5_canvas_image.gif');
		//arrowSprite.loadTexture('profilepic', 0);
	}

	function onClick()
	{
		if(fullScreen)
		{
			ResizeButton(fullScreenBtn, finalImageWidth);
			fullScreenBtn.x = fullScreenBtnX;
			fullScreenBtn.y = fullScreenBtnY;
			move = 1;
			topMostGrp.remove(fullScreenBtn);
			buttonGrp.add(fullScreenBtn);
			//topGrp.bringToTop();
			
			fullScreen = 0;
			fullScreenBtn = null;
			fullScreenBtnX = 0;
			fullScreenBtnY = 0;
		}
		else
		{
			if (toolbarButtonClicked == 1)
			{
				toolbarButtonClicked = 0;
			}
			else
			{
				move = !move;
				if (move == false)
				{
					arrowSprite.body.rotateRight(0);
					
					//TODO: if we stopped, we should show whatever image is selected!
					//check the frame names of the button that we are hitting!
					
					button = getSelectedButton();
					console.log('button name: ', button.name);

					
					if ((button.key != "buttonNoPicW") && (button.key != "buttonNoPicB"))
					{
						//get current button scale:
						var scale = button.scale.x;
						//calculate the button original Width/height
						var originalWidth = button.width/scale;
						var originalHeight = button.height/scale;
						
						//Now calculate what should be the next width/height
						var newProportionW = gameWidth/originalWidth;
						var newProportionH = gameHeight/originalHeight;
						
						fullScreenBtn = button;
						fullScreenBtnX = button.x;
						fullScreenBtnY = button.y;
						
						game.add.tween(button.scale).to( { x: newProportionW, y: newProportionH }, 2000, Phaser.Easing.Linear.None, true);
						game.add.tween(button).to( { x: 0, y: 0 }, 2000, Phaser.Easing.Linear.None, true);
						
						//change button to be topmost!
						buttonGrp.remove(button);
						topMostGrp.add(button);
						fullScreen = 1;
					}
				}
			}
		}
	}
	
	function getSelectedButton()
	{
		var button;
		var angle = arrowSprite.body.angle;
		if(angle > -22.5 && angle <= 22.5)
		{
			button = buttonMiddleR;
		}
		else if(angle > 22.5 && angle <= 67.5)
		{
			button = buttonBottomR;
		}
		else if(angle > 67.5 && angle <= 112.5)
		{
			button = buttonBottomM;
		}
		else if(angle > 112.5 && angle <= 157.5)
		{
			button = buttonBottomL;
		}
		else if(angle > 157.5 || angle <= -157.5)
		{
			button = buttonMiddleL;
		}
		else if(angle > -157.5 && angle <= -112.5)
		{
			button = buttonTopL;
		}
		else if(angle > -112.5 && angle <= -67.5)
		{
			button = buttonTopM;
		}
		else if(angle > -67.5 && angle <= -22.5)
		{
			button = buttonTopR;
		}
		
		return button;
	}
	
	function update() {

		if (move)
		{
			arrowSprite.body.rotateRight(speed);
		}
	}

	function render() {
				
		//var button = getSelectedButton();
		//if button.key != buttonNoPic
		//
		
		var button = getSelectedButton();
		
		clearBMDRect(spriteTL.key);
		clearBMDRect(spriteTM.key);
		clearBMDRect(spriteTR.key);
		clearBMDRect(spriteML.key);
		clearBMDRect(spriteMR.key);
		clearBMDRect(spriteBL.key);
		clearBMDRect(spriteBM.key);
		clearBMDRect(spriteBR.key);

		//if ((button.key != "buttonNoPicW") && (button.key != "buttonNoPicB"))
		{
			if (button.name == "TL")	{
				paintBMDRect(spriteTL.key, rectangleTL.width, rectangleTL.height, tintColor);
			} else if(button.name == "TM") {
				paintBMDRect(spriteTM.key, rectangleTM.width, rectangleTM.height, tintColor);
			} else if(button.name == "TR") {
				paintBMDRect(spriteTR.key, rectangleTR.width, rectangleTR.height, tintColor);
			} else if(button.name == "ML") {
				paintBMDRect(spriteML.key, rectangleML.width, rectangleML.height, tintColor);
			} else if(button.name == "MR") {
				paintBMDRect(spriteMR.key, rectangleMR.width, rectangleMR.height, tintColor);
			} else if(button.name == "BL") {
				paintBMDRect(spriteBL.key, rectangleBL.width, rectangleBL.height, tintColor);
			} else if(button.name == "BM") {
				paintBMDRect(spriteBM.key, rectangleBL.width, rectangleBM.height, tintColor);
			} else if(button.name == "BR") {
				paintBMDRect(spriteBR.key, rectangleBR.width, rectangleBR.height, tintColor);
			}
		}
	}
	
    window.onload = function() {
		game = new Phaser.Game("100", "100", /*gameWidth+toolbarSz, gameHeight, */ Phaser.AUTO, 'VirtualDialScan', { preload: preload, create: create, update: update, render: render });
    };

    </script>

    </body>
</html>